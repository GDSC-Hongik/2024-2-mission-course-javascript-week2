# 프론트엔드와 백엔드 소통

웹 애플리케이션을 개발하는 과정에서 프론트와 백엔드의 연결은 필수적인 단계이다.  
프론트엔드는 사용자에게 보이는 인터페이스를 담당하며, 백엔드는 데이터 처리, 로직 실행, 인증과 같은 서버 측 작업을 처리함  
두 컴포넌트가 서로 어떻게 통신하고 데이터를 주고 받을 수 있는지 이해하는 것이 매우 중요하다.

## 프론트엔드와 백엔드의 구분

**프론트엔드**

- 사용자 인터페이스 : 프론트엔드는 사용자가 직접 상호작용하는 부분으로 웹페이지의 레이아웃, 디자인, 인터랙션 등을 담당
- 테그놀로지 : HTML, CSS, JavaScript 등의 언어와 라이브러리(React, Angulr 등등) 또는 프레임워크를 사용
- 클라이언트 측 : 프론트엔드 코드는 사용자의 브라우저에서 실행
- 데이터 표시 : 프론트엔드는 백엔드에서 받은 데이터를 사용자에게 표시하고, 사용자의 입력을 백엔드로 전달

**백엔드**

- 서버와 데이터 처리 : 백엔드는 데이터베이스와 서버 로직을 관리. 데이터의 CRUD(Create, Read, Update, Delete) 작업을 담당하며 비즈니스 로직을 처리
- 테크놀로지 : 백엔드 개발에는 Python(Django, Flask), JavaScript(Node.js), Java(Spring), Ruby(Ruby on Rails), PHP(Laravel) 등 다양한 언어와 프레임워크가 사용됨
- 서버 측 : 백엔드 코드는 서버에서 실행됨. 서버는 클라이언트의 요청을 받아 적절한 응답을 제공
- 데이터 저장 : 대게 RDBMS나 NoSQL 데이터베이스를 사용해 데이터를 저장하고 관리

## 프론트엔드와 백엔드 연결 원리

<img src = "https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202309/112159-1143/group-1410116844.png">

<br>

**HTTP 프로토콜** : 프론트엔드와 백엔드는 대개 HTTP를 통해 통신

**API** : 백엔드 서버는 특정 엔드포인트를 통해 데이터나 기능을 제공하며, 프론트엔드는 이 엔드포인트에 요청을 보내 데이터를 받거나 처리

**비동기 통신** : 현대 웹 앱에서는 AJAX나 Fetch API, Axios 등을 사용하여 비동기적으로 데이터를 주고 받음

## 프론트엔드와 백엔드 연결 방법

- RESTful API : 가장 일반적인 방법, 백엔드에서 RESTful 원칙을 따르는 API를 제공하고, 프론트엔드에서는 이 API를 호출함  
  예시 ) GET/users, POST/users

- GraphQL : 요즘 많이 사용되는 새로운 기술, 프론트엔드에서 필요한 데이터 형식을 지정하여 요청할 수 있음

- WebSocket : 실시간 통신이 필요한 경우 사용되며, HTTP보다 더 빠른 양방향 통신을 지원함

- Server-Sent Events(SSE) : 서버에서 클라이언트로 실시간으로 데이터를 전송할 때 사용됨

<br>

예시 : JavaScript Fetch API를 사용한 RESTful API 호출

프론트엔드 :

```Javascript
fetch('http://localhost:3000/users')
 .then(response=>response.json())
 .then(data=>console.log(data))
 .catch(error=>console.log('Error:', error));
```

백엔드(Node.js + Express) :

```Javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/users', (req, res) => {
    res.json([{name:'Alice'}, {name:'Bob'}]);
});

app.listen(port, () => {
    console.log('Server running at http://localhost:${port}/');
});
```

# HTTP Response와 Request

## HTTP

HTTP는 HyperText Transfer Protocol의 약자  
**HyperText**를 직역하자면 초월적인 텍스트인데 이는 텍스트 간 이동할 때, 순차적 접근 방식이 아닌 비순차적 접근 방식을 따르는 텍스트를 의미함  
**Transfer Protocol**은 통신 장비 간 데이터 교환 방식에 대해 합의한 내용임. 통신을 원하는 두 개체가 무엇을, 어떻게 통신할 것인가에 대해 약속하고 이를 규칙으로 정의해놓은 것

=> HTTP는 하이퍼텍스트를 전송하기 위한 통신 규약을 의미

### HTTP 특징

1.  웹에서 이루어지는 모든 데이터 교환의 기초
2.  클라이언트-서버 프로토콜

    클라이언트-서버 프로토콜 : 클라이언트(보통은 웹브라우저) 요청을 생성하기 위해 연결을 연 다음 응답을 받을때까지 기다리는 모델로 각각의 요청은 클라이언트에 의해 초기화됨

    이 둘은 데이터 스트림이 아닌 개별적인 메시지 교환을 통해 통신함

    클라이언트에 의해 전송되는 메시지를 **요청**이라고 하고, 요청에 대해 서버에서 응답으로 전송하는 메시지를 **응답**이라고 함

3.  상태가 없고, 세션이 있다

- 상태를 저장하지 않음  
  예시 : `www.sample.com/page1` 요청 후 `www.sample.com/page2`를 요청하는 경우, 이 둘의 요청은 서로 연관성을 가지지 않고 독립적 -> 페이지1에서 만들어진 데이터는 페이지2를 요청할 때 유지되지 않음

- 이는 e-커머스 장바구니처럼, 사용자가 일관된 방식으로 페이지와 상호작용하길 원할 때 문제가 됨  
  하지만 HTTP는 상태가 없음에서 HTTP 쿠키를 사용하면 상태를 저장하는 세션을 사용할 수 있음

          HTTP 쿠키 : 서버가 웹 브라우저에 전송하는 작은 데이터 조각
          브라우저는 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송함. 쿠키는 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용하며, 이를 통해 사용자의 로그인 상태를 유지할 수 있음

4. 확장 가능

   HTTP 헤더를 사용하면 HTTP를 확장하기 쉬움  
   클라이언트와 서버가 새로운 헤더에 대해 합의한다면, 새로운 기능을 언제든지 추가할 수 있음

### HTTP의 흐름

클라이언트가 서버와 통신하고자 할 때, 최종 서버가 됐든 중간 프록시가 됐든, 다음 단계의 과정을 수행함

1.  TCP 연결을 연다 : TCP 연결은 요청을 보내거나 응답을 받는데 사용됨  
    클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 서버로 가는 여러 개의 TCP 연결을 열 수 있음

        - **TCP(전송 제어 프로토콜)**
          - 두 개의 호스트를 연결하고 데이터를 교환하게 해주는 중요한 네트워크 프로토콜
          - TCP 통신을 할 때 서버가 통신할 준비가 되어 있는지, 서로 연결해서 데이터를 주고 받을 수 있는지 확인함
          준비가 되었다면 통신을 하게 되고, 준비가 안 되었다면 서버가 준비가 안됐다는 메시지 혹은 에러를 사용자에게 보여줄 수 있음
          - TCP는 데이터와 패킷이 보내진 순서대로 전달되는 것을 보장
          TCP의 역할은 에러가 없이 패킷이 신뢰할 수 있게 전달되었는지 보증해주는 것

2.  HTTP 메시지를 전송(요청)

    전송되는 HTTP 메시지 형태

    > GET / HTTP/1.1  
    > Host: developer.mozilla.org  
    > Accept-Language: fr

3.  요청에 맞게 서버가 보내준 응답을 읽음

    > HTTP/1.1 200 OK  
    > Date: Sat, 09 Oct 2010 14:28:02 GMT  
    > Server: Apache  
    > Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT  
    > ETag: "51142bc1-7449-479b075b2891b"  
    > Accept-Ranges: bytes  
    > Content-Length: 29769  
    > Content-Type: text/HTML  
    >  <br>
    > `<!DOCTYPE html ... (requested web page)>`

4.  연결을 닫거나 다른 요청을 위해 연결을 재사용하거나

## HTTP 메시지

- HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식을 말함  
  ASCII로 인코딩된 텍스트 정보이며 여러줄로 되어 있음
- 요청과 응답 두 가지 타입이 존재하며, 각각 특정한 포맷을 가지고 있음
- HTTP 메시지는 설정 파일, API, 혹은 다른 인터페이스를 통해 제공됨
- 단순한 메시지 구조를 이루고 있고, 확장성이 좋음

#### 공통된 구조

1. 시작 줄(start-line) : HTTP 요청 또는 요청에 대한 성공/실패가 기록됨, 항상 한줄
2. HTTP 헤더 : 시작 줄 다음으로 요청에 대한 설명 또는 메시지 본문에 대한 설명이 들어감
3. 빈 줄 : 요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄이 삽입
4. 본문 : 요청과 관련된 데이터(HTML form 콘텐츠 등) 또는 응답과 관련된 문서(document)가 선택적으로 들어감  
   본문의 존재와 크기는 시작 줄 및 HTTP 헤더에 명시되어 있음

HTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 요청 헤드라고 부르며  
이와 반대로 HTTP 메시지의 페이로드는 본문이라고 함

## HTTP Request(요청)

요청은 클라이언트가 서버로 전달하는 메시지로, 서버 측 액션을 유도함

#### 시작 줄

> 시작 줄 : HTTP 메소드 + URI + HTTP 버전

1.  HTTP 메소드 : 영어 동사(GET, PUT, POST) 혹은 명사(HEAD, OPTIONS)를 사용해 서버가 수행해야 할 동작을 나타냄

    - HTTP 메소드 사용하는 이유 : 리소스와 동작을 분리하기 위해
    - HTTP 메소드 종류 : GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT  
    주로 GET, POST, PUT, DELETE, PATCH를 사용

      <br>

    - GET 메소드

      - 리소스를 조회하는 메소드  
        예를 들어 서버에게 클라이언트가 "이 페이지 보여줘"라고 요청하는 경우  
        혹은 URL 입력이나, 링크를 클릭하는 경우도 GET 요청에 해당
      - GET 요청은 멱등성이라는 개념을 지니고 있어 여러번 조회 요청을 하여도 리소스는 변하지 않음
      - GET 요청에서 서버에 데이터를 전달하는 경우, 쿼리 스티링을 통해 전달
      - 쿼리 스트링은 클라이언트에게 전달하는 데이터 정보가 무방비 상태로 노출되므로 유의해야 함

    - POST 메소드

      - 주로 새로운 리소스를 생성하는데 사용
      - 성공적으로 생성을 완료하면 201(Created) HTTP 응답을 반환
      - 데이터를 메시지 바디에 쿼리 파라미터 형식으로 전달  
        쿼리 파라미터는 key-value 형식  
        데이터가 외부로 노출되지 않으므로 보안상의 이점이 있음
      - POST로 조회가 가능하나 해당 메소드는 멱등성을 지니지 않으므로 여러번 수행할 경우 같은 결과값이 나오는 것을 보장하지 않음
      - 데이터 전송할 때, body에 담아 전송하므로 메시지 길이의 제한이 없음
      - 문자열 데이터 뿐만 아니라, RadioButton과 같은 객제들의 값도 전송할 수 있음

    - PUT 메소드

      - 리소스를 완전히 대체하는 개념(덮어쓰기)
      - 클라이언트가 리소스를 식별할 수 있음 => 클라이언트가 구체적인 리소스 위치를 아는 상태에서 URI를 지정  
        예시 ) PUT/posts/1 : 1번 게시글 수정 요청
      - 부분 수정은 불가능  
        만약 기존에 A, B라는 데이터가 존재했는데 C라는 데이터를 담아 PUT 요청을 보낸다면, A, B 모두 삭제되고 C로 대체되는 개념
      - 멱등성을 지님

    - PATCH 메소드

      - PUT과 같이 리소스를 수정하는 역할을 하지만, 리소스를 부분 변경한다는 점에서 차이 존재
      - 기존 데이터 A, B가 존재할 때 B = C 로 대체 후 PATCH 요청을 하면 데이터가 A, C로 변경
      - PATCH 메서드를 지원하지 않는 서버도 있는데, 그럴 경우 POST 사용
      - 멱등성 지니지 않음

    - DELETE 메소드

      - 리소스를 제거하는 역할
      - 멱등성을 지님

    - HEAD 메소드 : GET 메소드와 동일하나 HTTP 메시지의 body 부분을 제외하고 조회
    - OPTIONS 메소드 : 서버와 브라우저가 통신하기 위해 통신 옵션을 확인하기 위함  
      => 서버가 어떤 method, header, content-type을 제공하는지 알 수 있음
    - CONNECT 메소드 : 대상 자원으로 식별되는 서버에 대한 연결 요청

2.  URI : URL, 또는 프로토콜, 포트, 도메인의 절대 경로가 나옴

    - `origin 형식` : 끝에 `?`와 같은 쿼리 문자열이 붙는 절대 경로  
      가장 일반적인 형식으로 `GET`, `POST`, `HEAD`, `OPTIONS` 메소드와 함께 쓰임

          ```
          POST/HTTP 1.1
          GET/background.png HTTP/1.0
          HEAD/test.html?query=alibaba HTTP/1.1
          OPTIONS/anypage.html HTTP/1.0

          (참고)
          - HEAD : 웹 서버에서 헤더 정보 이외에는 어떤 데이터도 보내지 않음
          웹 서버의 다운 여부 점검이나 웹 서버 정보 등을 얻기 위해 사용될 수 있음
          - OPTIONS 메소드 : 특정 엔드포인트가 어떤 메소트를 허용하는지 알고자 할 때 사용
          ```

    - `absolute` 형식 : 완전한 URL 형식  
      프록시에 열결하는 경우 대부분 `GET`와 함께 쓰임

      ```
      GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages
      HTTP/1.1
      ```

    - `authority` 형식 : 도메인 이름 및 옵션 포트(`:`가 앞에 붙은 형태)로 이루어진 URL의 authority component  
      HTTP 터널을 구축하는 경우에만 `CONNECT`와 함께 사용

      ```
      CONNECT developer.mozilla.org:80 HTTP/1.1
      ```

    - `asterisk` 형식 : `OPTIONS`와 함께 별표(\*) 하나로 간단하게 서버 전체를 나타냄
      ```
      OPTIONS * HTTP/1.1
      ```

3.  HTTP 버전 : 메시지의 남은 구조는 명시된 버전에 따라 달라짐  
    또한 응답 메시지에서 써야 할 HTTP 버전을 알려주는 역할을 함

#### 헤더

- HTTP 헤더는 대소문자를 구분하지 않는 이름, 콜론, 값으로 구성(단 값 앞의 공백은 무시)
- 헤더는 값까지 포함해 한 줄로 구성
- 헤더 종류

  - Request 헤더 : 요청의 내용을 좀 더 구체화하고, 컨덱스트를 제공  
    조건부로 제한하여 요청 내용을 수정하기도 함
  - General 헤더 : 메시지 전체에 적용되는 헤더
  - Entity 헤더 : 요청 본문에 적용되는 헤더  
    요청 내에 본문이 없는 경우에는 당연히 전송되지 않음

#### 본문

- 본문은 요청의 마지막 부분에 들어가며, 모든 요청에 본문이 들어가지는 않음  
  `GET`, `DELETE`, `OPTIONS` 처럼 리소스를 가져오는 요청에서는 보통 본문이 필요없음
- 일부 요청은 업데이트를 하기 위해 서버에 데이터를 전송  
  보통(HTML Form 데이터를 포함하는) `POST` 요청일 경우 서버에 데이터를 전송
- 본문의 두 종류

  - 단일-리소스 본문 : 헤더 두개(`Content-Type`와 `Content-Length`)로 정의된 단일 파일로 구성
  - 다중-리소스 본문 : `multipart` 본문으로 구성, 파트마다 다른 정보를 포함

## HTTP Response(응답)

응답은 요청에 대한 서버의 답변

#### 상태 줄

- HTTP 응답의 시작 줄을 상태 줄이라고 함

  > 프로토콜 버전 + 상태 코드 + 상태 텍스트

1. 프로토콜 버전 : 보통 `HTTP/1.1`
2. 상태 코드 : 요청의 성공 또는 실패를 숫자 코드로 나타냄  
   예시 ) `200`, `404`, `302` 등등
3. 상태 텍스트 : 짧고 간결하게 상태 코드에 대한 설명을 글로 나타내어 사람들이 HTTP 메시지를 이해할 때 도움이 됨

- 일반적으로 `HTTP/1.1 200 OK` 나 `HTTP/1.1 404 Not Found.` 와 같이 생김

#### 헤더

- 요청의 헤더와 동일

#### 본문

- 본문은 요청의 마지막 부분에 들어가며, 모든 응답에 본문이 들어가지는 않음  
  `201`, `204`와 같은 상태 코드를 가진 응답에는 보통 본문이 없음
- 본문의 세 종류

  - 이미 길이가 알려진 단일 파일로 구성된 단일-리소스 본문 : 헤더 두개(`Content-Type`, `Content-Length`)로 정의
  - 길이를 모르는 단일 파일로 구성된 단일-리소스 본문 : `Transfer-Encoding`이 `chunked`로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩 되어 있음
  - 서로 다른 정보를 담고 있는 `multipart`로 이루어진 다중 리소스 본문

#### 상태 코드

서버에서의 처리 결과는 응답 메시지의 상태 줄에 있는 상태 코드를 보고 파악할 수 있음  
상태 코드는 세자리 숫자로 되어 있는데 첫 번째 숫자는 HTTP 응답의 종류를 구분하는 데 사용하며 나머지 2개의 숫자는 세부적은 응답 내용 구분을 위한 번호

- 1XX : Informational(정보 제공)

| 상태코드 | 상태 텍스트         | 뜻            | 서버 측면에서의 의미                                                                                             |
| -------- | ------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------- |
| 1XX      | Informational       | 정보 제공     | 클라이언트의 요청을 받았으며 작업을 계속 진행하고 있음                                                           |
| 100      | Continue            | 계속          | 계속 진행하기                                                                                                    |
| 101      | Switching Protocols | 프로토콜 전환 | 프로토콜로 전환하라                                                                                              |
| 102      | Processing          | 처리중        | 처리 중 - 서버가 처리되는 데 오랜 시간이 예상되어 클라이언트에서 타임 아웃이 발생하지 않드록 이 응답 코드를 보냄 |

- 2XX : Success(성공)

| 상태코드 | 상태 텍스트                   | 뜻                  | 서버 측면에서의 의미                                                          |
| -------- | ----------------------------- | ------------------- | ----------------------------------------------------------------------------- |
| 2XX      | Success                       | 성공                | 클라이언트가 요청한 동작을 수신하여 이해하였고 승낙하였으며 성공적으로 처리함 |
| **200**  | OK                            | 성공                | 서버가 요청을 성공적으로 처리                                                 |
| **201**  | Created                       | 생성됨              | 요청이 처리되어 새로운 리소스가 생성됨                                        |
| **202**  | Accepted                      | 허용됨              | 요청은 접수하였지만 처리가 완료되지 않음                                      |
| 203      | Non-Authoritative Information | 신뢰할 수 없는 정보 | 응답 헤더가 오리지널 서버로부터 제공된 것이 아님                              |
| 204      | No Content                    | 콘텐츠 없음         | 처리는 성공하였지만 클라이언트에게 돌려줄 콘텐츠가 없음                       |
| 205      | Reset Content                 | 콘텐츠 재설정       | 처리를 성공하였고 브라우저의 화면을 리셋하기                                  |
| 206      | Partial Content               | 일부 콘텐츠         | 콘텐츠의 일부만을 보냄                                                        |
| 207      | Multi-Status                  | 다중 상태           | 처리 결과의 상태가 여러개                                                     |

- 3XX : Redirection(리다이렉션)

| 상태코드 | 상태 텍스트        | 뜻              | 서버 측면에서의 의미                                  |
| -------- | ------------------ | --------------- | ----------------------------------------------------- |
| 3XX      | Redirection        | 리다이렉션      | 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 함 |
| 300      | Multiple Choices   | 여러 선택 항목  | 선택 항목이 여러개                                    |
| **301**  | Moved Permanently  | 영구 이동       | 지정한 리소스가 새로운 URI로 이동                     |
| 302      | Found              | 다른 위치 찾음  | 요청한 리소스를 다른 URI에서 찾음                     |
| **303**  | See Other          | 다른 위치 보기  | 다른 위치로 요청                                      |
| 304      | Not Modified       | 수정되지 않음   | 마지막 요청 이후 요청한 페이지는 수정되지 않음        |
| 305      | Use Proxy          | 프록시 사용     | 지정한 리소스에 액세스하려면 프록시를 통해야 함       |
| **307**  | Temporary Redirect | 임시 리다이렉션 | 임시로 리다이렉션 요청이 필요                         |

- 4XX : Client Error(클라이언트 에러)

  자주 사용되는 상태 코드만 정리함

| 상태코드 | 상태 텍스트  | 뜻              | 서버 측면에서의 의미                    |
| -------- | ------------ | --------------- | --------------------------------------- |
| 4XX      | Client Error | 클라이언트 에러 | 클라이언트의 요청에 오류 존재           |
| **400**  | Bad Request  | 잘못된 요청     | 요청의 구문이 잘못됨                    |
| **401**  | Unauthorized | 권한 없음       | 지정한 리소스에 대한 액세스 권한이 없음 |
| **403**  | Forbidden    | 금지됨          | 지정한 리소스에 대한 액세스가 금지됨    |
| **404**  | Not Found    | 찾을 수 없음    | 지정한 리소스를 찾을 수 없음            |

- 5XX : Server Error(서버 에러)

| 상태코드 | 상태 텍스트                | 뜻                   | 서버 측면에서의 의미                                                                            |
| -------- | -------------------------- | -------------------- | ----------------------------------------------------------------------------------------------- |
| 5XX      | Server Error               | 서버 에러            | 클라이언트의 요청은 유효한데 서버가 처리에 실패함                                               |
| **500**  | Internal Server Error      | 내부 서버 오류       | 서버에 에러가 발생                                                                              |
| **501**  | Not Implemented            | 구현되지 않음        | 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않음                                            |
| **502**  | Bad Gateway                | 불량 게이트웨이      | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받음               |
| 503      | Service Unavailable        | 서비스 제공 불가     | 현재 서버에서 서비스를 제공할 수 없음                                                           |
| 504      | Gateway Timeout            | 게이트웨이 시간 초과 | 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 응답을 기다리다 시간 초과가 발생 |
| 505      | HTTP Version Not Supported | HTTP 버전 미지원     | 클라이언트가 요청에 사용한 HTTP 버전을 서버가 지원하지 않음                                     |
| 507      | Insufficient Storage       | 용량 부족            | 서버에 저장 공간 부족으로 처리에 실패함                                                         |
