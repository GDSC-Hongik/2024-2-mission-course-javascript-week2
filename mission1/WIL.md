# 프론트엔드 백엔드 연결

## Chapter 1. 프론트엔드와 백엔드는 어떻게 구분될까?

프론트엔드 (Front-end)

✅ 사용자 인터페이스 : 프론트엔드는 사용자가 직접 상호작용하는 부분입니다. 웹 페이지의 레이아웃, 디자인, 인터랙션 등을 담당합니다.

✅ 테크놀로지 : HTML, CSS, JavaScript 등의 언어와 라이브러리(예: React, Angular, Vue.js) 또는 프레임워크를 사용합니다.

✅ 클라이언트 : 프론트엔드 코드는 사용자의 브라우저에서 실행됩니다.

✅ 데이터 표시 : 프론트엔드는 백엔드에서 받은 데이터를 사용자에게 표시하고, 사용자의 입력을 백엔드로 전달합니다.

백엔드 (Back-end)

✅ 서버와 데이터 처리: 백엔드는 데이터베이스와 서버 로직을 관리합니다.
데이터의 CRUD(Create, Read, Update, Delete) 작업을 담당하며, 비즈니스 로직을 처리합니다.

✅ 테크놀로지: 백엔드 개발에는 Python (Django, Flask), JavaScript (Node.js), Java (Spring), Ruby (Ruby on Rails), PHP (Laravel) 등 다양한 언어와 프레임워크가 사용됩니다.

✅ 서버 측: 백엔드 코드는 서버에서 실행됩니다. 서버는 클라이언트의 요청을 받아 적절한 응답을 제공합니다.

✅ 데이터 저장: 대게 RDBMS(예: MySQL, PostgreSQL)나 NoSQL(예: MongoDB, Cassandra) 데이터베이스를 사용해 데이터를 저장하고 관리합니다.

## Chapter 2. 프론트엔드와 백엔드 연결 원리

✅ HTTP 프로토콜: 프론트엔드와 백엔드는 대개 HTTP(HyperText Transfer Protocol)를 통해 통신합니다.

✅ API (Application Programming Interface): 백엔드 서버는 특정 엔드포인트를 통해 데이터나 기능을 제공하며, 프론트엔드는 이 엔드포인트에 요청을 보내 데이터를 받거나 처리합니다.

✅ 비동기 통신: 현대 웹 앱에서는 AJAX(Asynchronous JavaScript and XML)나 Fetch API, Axios 등을 사용하여 비동기적으로 데이터를 주고 받습니다.

## Chapter 3. 프론트엔드와 백엔드 연결 방법

✅ RESTful API: 가장 일반적인 방법으로, 백엔드에서 RESTful 원칙을 따르는 API를 제공하고, 프론트엔드에서는 이 API를 호출합니다.
예: GET /users, POST /users

✅ GraphQL: 요즘 많이 사용되는 새로운 기술로, 프론트엔드에서 필요한 데이터 형식을 지정하여 요청할 수 있습니다.

✅ WebSocket: 실시간 통신이 필요한 경우 사용되며, HTTP보다 더 빠른 양방향 통신을 지원합니다.

✅Server-Sent Events (SSE): 서버에서 클라이언트로 실시간으로 데이터를 전송할 때 사용됩니다.

## HTTP Method

: 서버 구조에서 요청과 응답이 이루어지는 방식. 서버가 수행해야 할 동작을 지정하여 요청을 보내는 방법

### GET Method

- 리소스를 조회하는 메서드
  - 서버에게 클라이언트가 "이 페이지 보여줘"라고 요청하는 경우
  - URL 입력이나, 링크를 클릭하는 경우도 GET 요청에 해당한다.
- GET 요청은 '멱등성'이라는 개념을 지니고 있어, 여러번 조회 요청을 하여도 리소스는 변하지 않는다.
- GET 요청에서 서버에 데이터를 전달하는 경우, 쿼리스트링을 통해서 전달.

### POST Method

- 새로운 리소스를 생성하는데 사용
- 성공적으로 creation을 완료하면 201 HTTP 응답 반환.
- 데이터를 메세지 바디에 쿼리 파라미터 형식으로 전달.
  - 쿼리 파라미터는 key-value 형식으로 되어 있다.
  - GET 방식과 비교하면, 데이터가 외부로 노출되지 않으므로, 보안상의 이점이 있다.

### PUT Method

- 리소스를 완전히 대체하는 개념(덮어쓰기)
- 클라이언트가 리소스를 식별할 수 있다.
  - 클라이언트가 구체적인 리소스 위치를 아는 상태에서, URL 지정
- 부분 수정 불가. 만약 기존에 A, B라는 데이터가 존재했는데, C라는 데이터를 담아 PUT요청을 보낸다면, A,B 모두 삭제되고 C로 대체되는 개념
- 멱등석을 지님

### PATCH Method

- PUT과 같이 리소스를 수정하는 역할을 하지만, 리소스를 부분 변경
- 기존 데이터 A,B가 존재할 때, B=C로 대체 후 PATCH 요청을 하면 데이터 변경

### Delete Method

- 리소스를 제거하는 역할
- 멱등성을 지닌다.

출처: <https://youwjune.tistory.com/42>

## HTTP Status Code

- 1XX: Informational(정보 제공)
  임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미입니다. HTTP 1.1 버전부터 추가되었습니다.
- 2XX: Success(성공)
  클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미입니다.
- 3XX: Redirection(리다이렉션)
  완전한 처리를 위해서 추가 동작이 필요한 경우입니다. 주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미입니다.
- 4XX: Client Error(클라이언트 에러)
  없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미합니다.
- 5XX: Server Error(서버 에러)
  서버 사정으로 메시지 처리에 문제가 발생한 경우입니다. 서버의 부하, DB 처리 과정 오류, 서버에서 익셉션이 발생하는 경우를 의미합니다.

200 OK 성공
서버가 요청을 성공적으로 처리하였다.

201 Created 생성됨
요청이 처리되어서 새로운 리소스가 생성되었다.
응답 헤더 Location에 새로운 리소스의 절대 URI를 기록합니다.

202 Accepted 허용됨
요청은 접수하였지만, 처리가 완료되지 않았다.
응답 헤더의 Location, Retry-After를 참고하여 클라이언트는 다시 요청을 보냅니다.

301 Moved Permanently 영구 이동
지정한 리소스가 새로운 URI로 이동하였다.
이동할 곳의 새로운 URI는 응답 헤더 Location에 기록합니다.

303 See Other 다른 위치 보기
다른 위치로 요청하라.
요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할 수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드입니다.

307 Temporary Redirect 임시 리다이렉션
임시로 리다이렉션 요청이 필요하다.
요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다. 302의 의미를 정확하게 재정의해서 HTTP/1.1의 307 응답으로 추가되었습니다.

400 Bad Request 잘못된 요청
요청의 구문이 잘못되었다.
클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다.

401 Unauthorized 권한 없음
지정한 리소스에 대한 액세스 권한이 없다.
응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다.

403 Forbidden 금지됨
지정한 리소스에 대한 액세스가 금지되었다.

401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미합니다. 리소스의 존재 자체를 은폐하고 싶은 경우는 404 응답 코드를 사용할 수 있습니다.

404 Not Found 찾을 수 없음
지정한 리소스를 찾을 수 없다.

500 Internal Server Error 내부 서버 오류
서버에 에러가 발생하였다.
클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다.

501 Not Implemented 구현되지 않음
요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다.

502 Bad Gateway 불량 게이트웨이
게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.
